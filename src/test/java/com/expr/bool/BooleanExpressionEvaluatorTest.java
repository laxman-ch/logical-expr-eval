package com.expr.bool;/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.testng.TestNG;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import static org.testng.Assert.*;

@RunWith(JUnit4.class)
public class BooleanExpressionEvaluatorTest {
    ExpEvaluator evaluator;

    @BeforeMethod
    public void setUp() {
        evaluator = new ExpEvaluator();
    }

    @DataProvider(name = "rule-not-met-expressions")
    Object[][] basicTestsData() {
        return new Object[][] {
                {new ValidTestData("single variable", "a", false)},
                {new ValidTestData("AND", "a&b", false)},
                {new ValidTestData("OR", "a|b", false)},
                {new ValidTestData("NOT", "!a", false)},
                {new ValidTestData("parentheses", "(a&b)|c", false)},
                {new ValidTestData("Spaces", " a | b ", false)},
                {new ValidTestData("L2R Associativity", "a & b & c", false)},
                {new ValidTestData("R2L Associativity", "!!a", false)},
                {new ValidTestData("all operators", "(a|b)&!c", false)},
                {new ValidTestData("NOT combined with parenthesis", "!(a|b)&!c", false)},
                {new ValidTestData("Nested parenthesis", "!(a|b&(c&!d))&!c", false)}

        };
    }

    @DataProvider(name = "rule-met-expressions")
    Object[][] basicSuccessTestsData() {
        return new Object[][] {
                {new ValidTestData("single variable", "a|!a", true)},
                {new ValidTestData("multi variable", "(a|b)|!a", true)}
        };
    }

    @DataProvider(name = "invalid-expressions")
    Object[][] errorTestsData() {
        return new Object[][] {
                {new ErrorTestData("invalid variable name", "k")},
                {new ErrorTestData("invalid operator", "(a|b)+c")},
                {new ErrorTestData("mismatched parentheses", "(a|b))+c")},
                {new ErrorTestData("mismatched parentheses", "(a|b)+(c")}
        };
    }


    @Test(dataProvider = "rule-not-met-expressions")
    public void totalityRuleNotMetExpressions(ValidTestData data) {
        assertSame(data.expected, evaluator.checkTotality(data.expression), String.format("test name: %s, expression: %s is not expected to pass the totality principle", data.name, data.expression));
    }

    @Test(dataProvider = "rule-met-expressions")
    public void simpleExpressions(ValidTestData data) {
        assertSame(data.expected, evaluator.checkTotality(data.expression), String.format("test name: %s, expression: %s is expected to pass the totality principle", data.name, data.expression));
    }

    @Test(dataProvider = "invalid-expressions", expectedExceptions = MalformedExpressionException.class)
    public void invalidOperator(ErrorTestData data) {
        evaluator.checkTotality(data.expression);
        fail(String.format("test name: %s, expression: %s is expected to throw exception", data.name, data.expression));
    }
}


class ValidTestData {
    String name;
    String expression;
    boolean expected;

    public ValidTestData(String name, String expression, boolean expected) {
        this.name = name;
        this.expression = expression;
        this.expected = expected;
    }

    @Override
    public String toString() {
        return "{" +
               "name='" + name + '\'' +
               ", expression='" + expression + '\'' +
               ", expected=" + expected +
               '}';
    }
}

class ErrorTestData {
    String name;
    String expression;

    public ErrorTestData(String name, String expression) {
        this.name = name;
        this.expression = expression;
    }

    @Override
    public String toString() {
        return "ErrorTestData{" +
               "name='" + name + '\'' +
               ", expression='" + expression + '\'' +
               '}';
    }
}
